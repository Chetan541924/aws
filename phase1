from playwright.async_api import async_playwright
import os

execution_output = ""
execution_message = ""
final_status = "fail"

await websocket.send_text(json.dumps({
    "status": "RUNNING",
    "log": "Launching browser session..."
}))

async with async_playwright() as p:
    browser = await p.chromium.launch(
        headless=False,
        executable_path=os.environ.get("exe_path")
    )

    context = await browser.new_context()
    page = await context.new_page()

    logger.info(LogCategory.EXECUTION, "Browser launched")

    # ---------------- NAVIGATE TO APP ----------------
    await page.goto("YOUR_LOGIN_URL")

    await websocket.send_text(json.dumps({
        "status": "RUNNING",
        "log": "Navigated to application home"
    }))

    # ---------------- ADFS AUTOMATED LOGIN ----------------
    await websocket.send_text(json.dumps({
        "status": "RUNNING",
        "log": "ADFS login page detected. Performing automated login..."
    }))

    await page.wait_for_selector('input[placeholder="Standard ID"]', timeout=60000)

    await page.fill(
        'input[placeholder="Standard ID"]',
        os.environ["CCS_USERNAME"]
    )

    await page.fill(
        'input[placeholder="Password"]',
        os.environ["CCS_PASSWORD"]
    )

    await page.click('button:has-text("Sign in")')

    await websocket.send_text(json.dumps({
        "status": "RUNNING",
        "log": "Credentials submitted. Waiting for authentication redirect..."
    }))

    # Wait until redirected away from ADFS
    await page.wait_for_function("""
        () => !window.location.href.includes('/adfs/')
    """, timeout=120000)

    # ---------------- WAIT FOR CCS UI FRAME ----------------
    await websocket.send_text(json.dumps({
        "status": "RUNNING",
        "log": "Waiting for CCS UI frame to load..."
    }))

    await page.wait_for_function("""
        () => Array.from(window.frames).some(f =>
            f.location.href.includes('/ccs/')
        )
    """, timeout=120000)

    await websocket.send_text(json.dumps({
        "status": "RUNNING",
        "log": "CCS UI frame detected"
    }))

    # ---------------- DISCOVER CCS FRAMES ----------------
    await websocket.send_text(json.dumps({
        "status": "RUNNING",
        "log": "Discovering CCS frames..."
    }))

    for frame in page.frames:
        logger.info(LogCategory.EXECUTION, f"FRAME URL: {frame.url}")
        await websocket.send_text(json.dumps({
            "status": "RUNNING",
            "log": f"FRAME URL: {frame.url}"
        }))

    # ---------------- PHASE 1 COMPLETE ----------------
    execution_message = "Authentication completed and CCS UI loaded successfully"
    final_status = "success"

    # ---------------- PHASE 1.5: IDENTIFY FRAME ROLES ----------------
nav_frame = None
content_frame = None

for frame in page.frames:
    if "currentNavPosition.do" in frame.url:
        nav_frame = frame
    elif "ccs.do" in frame.url:
        content_frame = frame

if not nav_frame or not content_frame:
    raise RuntimeError("PHASE 1.5 FAILED: Required CCS frames not found")

await websocket.send_text(json.dumps({
    "status": "RUNNING",
    "log": "PHASE 1.5: Navigation and Content frames identified"
}))

# ---------------- PHASE 1.5 PROBE: CLICK CLAIMS ----------------
await websocket.send_text(json.dumps({
    "status": "RUNNING",
    "log": "PHASE 1.5 probe: Clicking 'Claims' to validate frame scoping"
}))

claims_locator = nav_frame.locator("text=Claims")

await claims_locator.wait_for(timeout=30000)
await claims_locator.click()

await websocket.send_text(json.dumps({
    "status": "RUNNING",
    "log": "PHASE 1.5 probe successful: 'Claims' clicked"
}))

# ---------------- VERIFY CONTENT FRAME STILL ACTIVE ----------------
await websocket.send_text(json.dumps({
    "status": "RUNNING",
    "log": "PHASE 1.5: Verifying content frame after probe click"
}))


    await browser.close()

await websocket.send_text(json.dumps({
    "status": "SUCCESS",
    "log": execution_message
}))
