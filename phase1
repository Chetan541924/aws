from playwright.async_api import async_playwright
import os

execution_output = ""
execution_message = ""
final_status = "fail"

await websocket.send_text(json.dumps({
    "status": "RUNNING",
    "log": "Launching browser session..."
}))

async with async_playwright() as p:
    browser = await p.chromium.launch(
        headless=False,
        executable_path=os.environ.get("exe_path")
    )

    context = await browser.new_context()
    page = await context.new_page()

    logger.info(LogCategory.EXECUTION, "Browser launched")

    # ---------------- NAVIGATE TO APP ----------------
    await page.goto("YOUR_LOGIN_URL")

    await websocket.send_text(json.dumps({
        "status": "RUNNING",
        "log": "Navigated to application home"
    }))

    # ---------------- ADFS AUTOMATED LOGIN ----------------
    await websocket.send_text(json.dumps({
        "status": "RUNNING",
        "log": "ADFS login page detected. Performing automated login..."
    }))

    await page.wait_for_selector('input[placeholder="Standard ID"]', timeout=60000)

    await page.fill(
        'input[placeholder="Standard ID"]',
        os.environ["CCS_USERNAME"]
    )

    await page.fill(
        'input[placeholder="Password"]',
        os.environ["CCS_PASSWORD"]
    )

    await page.click('button:has-text("Sign in")')

    await websocket.send_text(json.dumps({
        "status": "RUNNING",
        "log": "Credentials submitted. Waiting for authentication redirect..."
    }))

    # Wait until redirected away from ADFS
    await page.wait_for_function("""
        () => !window.location.href.includes('/adfs/')
    """, timeout=120000)

    # ---------------- WAIT FOR CCS UI FRAME ----------------
    await websocket.send_text(json.dumps({
        "status": "RUNNING",
        "log": "Waiting for CCS UI frame to load..."
    }))

    await page.wait_for_function("""
        () => Array.from(window.frames).some(f =>
            f.location.href.includes('/ccs/')
        )
    """, timeout=120000)

    await websocket.send_text(json.dumps({
        "status": "RUNNING",
        "log": "CCS UI frame detected"
    }))

    # ---------------- DISCOVER CCS FRAMES ----------------
    await websocket.send_text(json.dumps({
        "status": "RUNNING",
        "log": "Discovering CCS frames..."
    }))

    for frame in page.frames:
        logger.info(LogCategory.EXECUTION, f"FRAME URL: {frame.url}")
        await websocket.send_text(json.dumps({
            "status": "RUNNING",
            "log": f"FRAME URL: {frame.url}"
        }))

    # ---------------- PHASE 1 COMPLETE ----------------
    execution_message = "Authentication completed and CCS UI loaded successfully"
    final_status = "success"

    # ---------------- PHASE 1.5: IDENTIFY FRAME ROLES ----------------
nav_frame = None
content_frame = None

for frame in page.frames:
    if "currentNavPosition.do" in frame.url:
        nav_frame = frame
    elif "ccs.do" in frame.url:
        content_frame = frame

if not nav_frame or not content_frame:
    raise RuntimeError("PHASE 1.5 FAILED: Required CCS frames not found")

await websocket.send_text(json.dumps({
    "status": "RUNNING",
    "log": "PHASE 1.5: Navigation and Content frames identified"
}))

# ---------------- PHASE 1.5 PROBE: CLICK CLAIMS ----------------
await websocket.send_text(json.dumps({
    "status": "RUNNING",
    "log": "PHASE 1.5 probe: Clicking 'Claims' to validate frame scoping"
}))

claims_locator = nav_frame.locator("text=Claims")

await claims_locator.wait_for(timeout=30000)
await claims_locator.click()

await websocket.send_text(json.dumps({
    "status": "RUNNING",
    "log": "PHASE 1.5 probe successful: 'Claims' clicked"
}))

# ================= PHASE 2: STEP-WISE EXECUTION =================

await websocket.send_text(json.dumps({
    "status": "RUNNING",
    "log": "PHASE 2: Starting step-wise execution"
}))

logger.info(LogCategory.EXECUTION, "PHASE 2: Starting step-wise execution")

# ----------------------------------------------------------------
# Phase 2 runs ONLY current test case steps
# Prerequisites are already handled in Phase 1
# ----------------------------------------------------------------

steps = list(testplan_dict["current_bdd_steps"].items())

if not steps:
    await websocket.send_text(json.dumps({
        "status": "RUNNING",
        "log": "PHASE 2: No steps found in current test case"
    }))
else:
    for step_name, step_args in steps:

        step_category = classify_step(step_name)  # STATE / ACTION / ASSERT

        await websocket.send_text(json.dumps({
            "status": "RUNNING",
            "log": f"PHASE 2: Step -> {step_name} | Category -> {step_category}"
        }))

        logger.info(
            LogCategory.EXECUTION,
            f"[PHASE 2] Step: {step_name} | Category: {step_category}"
        )

        try:
            # ---------------- DOM OBSERVATION ----------------
            frame_snapshot = [frame.url for frame in page.frames]

            logger.info(
                LogCategory.EXECUTION,
                f"[PHASE 2][DOM] Frames: {frame_snapshot}"
            )

            await websocket.send_text(json.dumps({
                "status": "RUNNING",
                "log": f"[PHASE 2] DOM observed for {step_category} step"
            }))

            # ---------------- FRAME RESOLUTION ----------------
            nav_frame = None
            content_frame = None

            for frame in page.frames:
                if "currentNavPosition.do" in frame.url:
                    nav_frame = frame
                elif "ccs.do" in frame.url:
                    content_frame = frame

            if not nav_frame or not content_frame:
                raise RuntimeError("Required CCS frames not found")

            logger.info(
                LogCategory.EXECUTION,
                "[PHASE 2] CCS frames resolved successfully"
            )

            # ---------------- NO ACTION YET ----------------
            # Phase 3 will:
            # - choose correct frame
            # - resolve selector
            # - execute action/assert

        except Exception as e:
            logger.error(
                LogCategory.EXECUTION,
                f"[PHASE 2] Step failed: {step_name} | {str(e)}"
            )

            await websocket.send_text(json.dumps({
                "status": "FAILED",
                "log": f"PHASE 2: Step '{step_name}' failed due to {str(e)}"
            }))
            raise




    await browser.close()

await websocket.send_text(json.dumps({
    "status": "SUCCESS",
    "log": execution_message
}))
