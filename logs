# ---------------- STEP EXECUTION LOG : NAV_CLICK ----------------

step_counter += 1

# Resolve runtime values safely
frame_url = nav_frame.url if nav_frame else None

resolved_id = await link.get_attribute("id")
resolved_name = await link.get_attribute("name")
resolved_text = await link.text_content()

step_execution_logs.append({
    "step_order": step_counter,
    "gherkin_step": step_name,
    "step_type": "WHEN",
    "action_type": "NAV_CLICK",
    "status": "PASS",
    "error_message": None,

    # Frame details (resolved, not hardcoded)
    "frame_type": "navigation",
    "frame_url": frame_url,

    # Locator details (what ACTUALLY worked)
    "locator_strategy": "role",
    "locator_value": {
        "role": "link",
        "name": target
    },

    # Resolved element metadata
    "resolved_element_tag": "a",
    "resolved_element_text": resolved_text.strip() if resolved_text else None,
    "resolved_element_id": resolved_id,
    "resolved_element_name": resolved_name,
    "resolved_element_xpath": None,   # role-based click → xpath intentionally absent

    # Semantic input
    "input_value": target,

    # High confidence: role + visible name
    "confidence": "HIGH",

    "execution_ts": datetime.now().isoformat()
})


# ---------------- STEP EXECUTION LOG : BUTTON ----------------

step_counter += 1

# Resolve runtime values
frame_url = content_frame.url if content_frame else None

resolved_id = await btn.get_attribute("id")
resolved_name = await btn.get_attribute("name")
resolved_text = await btn.text_content()
resolved_value = await btn.get_attribute("value")

step_execution_logs.append({
    "step_order": step_counter,
    "gherkin_step": step_name,
    "step_type": "WHEN",
    "action_type": "BUTTON",
    "status": "PASS",
    "error_message": None,

    # Frame details (actual frame used)
    "frame_type": "content",
    "frame_url": frame_url,

    # Locator strategy ACTUALLY used
    # (semantic scan over button/value/text/id)
    "locator_strategy": "semantic_scan",
    "locator_value": {
        "button_name": button_name,
        "section": section,
        "matched_on": {
            "text": resolved_text,
            "value": resolved_value,
            "id": resolved_id
        }
    },

    # Resolved element metadata
    "resolved_element_tag": "button",
    "resolved_element_text": resolved_text.strip() if resolved_text else None,
    "resolved_element_id": resolved_id,
    "resolved_element_name": resolved_name,
    "resolved_element_xpath": None,   # intentionally omitted (semantic click)

    # Semantic input
    "input_value": button_name,

    # Medium–High confidence (semantic, not role-based)
    "confidence": "MEDIUM",

    "execution_ts": datetime.now().isoformat()
})




# ---------------- STEP EXECUTION LOG : INPUT ----------------

step_counter += 1

frame_url = content_frame.url if content_frame else None

resolved_id = await inp.get_attribute("id")
resolved_name = await inp.get_attribute("name")
resolved_aria = await inp.get_attribute("aria-label")

step_execution_logs.append({
    "step_order": step_counter,
    "gherkin_step": step_name,
    "step_type": "WHEN",
    "action_type": "INPUT",
    "status": "PASS",
    "error_message": None,

    # Frame details (resolved at action time)
    "frame_type": "content",
    "frame_url": frame_url,

    # Locator strategy actually used
    "locator_strategy": "semantic_input_match",
    "locator_value": {
        "field_name": field_name,
        "normalized_field": normalized_field,
        "resolution_mode": input_resolution_mode,  # strong | fallback
        "matched_on": {
            "id": resolved_id,
            "name": resolved_name,
            "aria-label": resolved_aria
        }
    },

    # Resolved element metadata
    "resolved_element_tag": "input",
    "resolved_element_text": None,
    "resolved_element_id": resolved_id,
    "resolved_element_name": resolved_name,
    "resolved_element_xpath": None,  # semantic match → xpath intentionally omitted

    # Input semantics
    "input_value": value,

    # Confidence scoring
    "confidence": "HIGH" if input_resolution_mode == "strong" else "MEDIUM",

    "execution_ts": datetime.now().isoformat()
})




select_resolution_case = None   # "ccs_action_dropdown" | "generic_select"
resolved_select_name = None
resolved_option_value = None


select_resolution_case = "ccs_action_dropdown"
resolved_option_value = await opt.get_attribute("value")
resolved_select_name = await sel.get_attribute("name")
await sel.select_option(value=resolved_option_value)

select_resolution_case = "generic_select"
resolved_option_value = await opt.get_attribute("value")
resolved_select_name = await sel.get_attribute("name")



# ---------------- STEP EXECUTION LOG : SELECT ----------------

step_counter += 1

frame_url = content_frame.url if content_frame else None

step_execution_logs.append({
    "step_order": step_counter,
    "gherkin_step": step_name,
    "step_type": "WHEN",
    "action_type": "SELECT",
    "status": "PASS",
    "error_message": None,

    # Frame details
    "frame_type": "content",
    "frame_url": frame_url,

    # Locator strategy actually used
    "locator_strategy": "select_option",
    "locator_value": {
        "resolution_case": select_resolution_case,
        "select_name": resolved_select_name,
        "selected_option_text": option_text,
        "selected_option_value": resolved_option_value
    },

    # Resolved element metadata
    "resolved_element_tag": "select",
    "resolved_element_text": None,
    "resolved_element_id": None,
    "resolved_element_name": resolved_select_name,
    "resolved_element_xpath": None,   # semantic select, xpath intentionally omitted

    # Input semantics
    "input_value": option_text,

    # Confidence
    "confidence": "HIGH" if select_resolution_case == "ccs_action_dropdown" else "MEDIUM",

    "execution_ts": datetime.now().isoformat()
})







account_resolution_mode = None   # index_word | numeric_index | masked_last4 | digit_match
resolved_row_index = None
resolved_href = None


account_resolution_mode = "index_word"
resolved_row_index = idx
resolved_href = await link_to_click.get_attribute("href")

account_resolution_mode = "numeric_index"
resolved_row_index = idx
resolved_href = await link_to_click.get_attribute("href")

account_resolution_mode = "masked_last4"
resolved_row_index = i + 1
resolved_href = href

account_resolution_mode = "digit_match"
resolved_row_index = i + 1
resolved_href = href


if "customer account list" in step_lower and "account number" in step_lower:
    action_type = "ACCOUNT_ROW_CLICK"

    result = await execute_account_row_click(page, step_name)

    # ---------------- STEP EXECUTION LOG : ACCOUNT_ROW_CLICK ----------------
    step_counter += 1

    step_execution_logs.append({
        "step_order": step_counter,
        "gherkin_step": step_name,
        "step_type": "WHEN",
        "action_type": "ACCOUNT_ROW_CLICK",
        "status": "PASS",
        "error_message": None,

        # Frame details
        "frame_type": "content",
        "frame_url": result["frame_url"],

        # Locator strategy actually used
        "locator_strategy": "account_row_resolution",
        "locator_value": {
            "resolution_mode": result["account_resolution_mode"],
            "row_index": result["resolved_row_index"],
            "total_rows": result["total_rows"],
            "matched_href": result["resolved_href"]
        },

        # Resolved element metadata
        "resolved_element_tag": "a",
        "resolved_element_text": None,
        "resolved_element_id": None,
        "resolved_element_name": None,
        "resolved_element_xpath": None,

        # Semantic input
        "input_value": step_name,

        # Confidence scoring
        "confidence": (
            "HIGH"
            if result["account_resolution_mode"] in ("masked_last4", "digit_match")
            else "MEDIUM"
        ),

        "execution_ts": datetime.now().isoformat()
    })

    continue
