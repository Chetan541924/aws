step_lower = step_name.lower()

if "click on the link" in step_lower:
    action_type = "NAV_CLICK"
elif "clicks the button" in step_lower:
    action_type = "BUTTON_CLICK"
elif "enters" in step_lower:
    action_type = "INPUT"
elif "selects" in step_lower:
    action_type = "SELECT"
else:
    raise RuntimeError("Unsupported ACTION step")

elif action_type == "BUTTON":
    if "name =" not in step_name:
        raise RuntimeError("BUTTON step missing button name")

    button_name = step_name.split("name =")[-1].strip().lower()

    # ALWAYS resolve frames at action time
    nav_frame, content_frame = resolve_ccs_frames(page)

    # CCS buttons are input[type=button|submit]
    buttons = content_frame.locator(
        "input[type='button'], input[type='submit'], button"
    )

    count = await buttons.count()
    if count == 0:
        raise RuntimeError("No buttons found on page")

    for i in range(count):
        btn = buttons.nth(i)

        value_attr = (await btn.get_attribute("value") or "").lower()
        id_attr = (await btn.get_attribute("id") or "").lower()
        text_attr = (await btn.text_content() or "").lower()

        if (
            button_name in value_attr
            or button_name in id_attr
            or button_name in text_attr
        ):
            await btn.scroll_into_view_if_needed()
            await btn.wait_for(state="visible", timeout=20000)
            await btn.click(force=True)

            logger.info(
                LogCategory.EXECUTION,
                f"[PHASE 3] BUTTON click successful: {button_name}"
            )
            return

    raise RuntimeError(f"Button '{button_name}' not found")


elif action_type == "INPUT":
    if "'" not in step_name or "name =" not in step_name:
        raise RuntimeError("INPUT step must contain quoted value and field name")

    # Extract value and logical field name
    value = step_name.split("'")[1].strip()
    field_name = step_name.split("name =")[-1].strip().lower()

    # Always resolve frames at action time
    _, content_frame = resolve_ccs_frames(page)

    # Normalize field name for matching
    normalized_field = field_name.replace(" ", "").replace("_", "")

    # Get all visible text inputs
    inputs = content_frame.locator("input[type='text']")
    count = await inputs.count()

    if count == 0:
        raise RuntimeError("No text input fields found")

    # ---------- PASS 1: STRONG semantic match ----------
    for i in range(count):
        inp = inputs.nth(i)

        id_attr = (await inp.get_attribute("id") or "").lower().replace(" ", "")
        name_attr = (await inp.get_attribute("name") or "").lower().replace(" ", "")
        aria_attr = (await inp.get_attribute("aria-label") or "").lower().replace(" ", "")

        if (
            normalized_field in id_attr or
            normalized_field in name_attr or
            normalized_field in aria_attr
        ):
            await inp.click()
            await inp.fill(value)

            logger.info(
                LogCategory.EXECUTION,
                f"[PHASE 3] INPUT successful: {field_name} = {value}"
            )
            return

    # ---------- PASS 2: Keyword-based semantic fallback ----------
    keywords = normalized_field.split()

    for i in range(count):
        inp = inputs.nth(i)
        combined = (
            (await inp.get_attribute("id") or "") +
            (await inp.get_attribute("name") or "") +
            (await inp.get_attribute("aria-label") or "")
        ).lower()

        if any(k in combined for k in keywords):
            await inp.click()
            await inp.fill(value)

            logger.info(
                LogCategory.EXECUTION,
                f"[PHASE 3] INPUT fallback successful: {field_name} = {value}"
            )
            return

    # ---------- HARD FAILURE ----------
    raise RuntimeError(f"Input field matching '{field_name}' not found")




elif action_type == "SELECT":
    if "'" not in step_name:
        raise RuntimeError("SELECT step missing quoted option")

    option_text = step_name.split("'")[1].strip()

    # ðŸ”´ ALWAYS re-resolve frames before interacting
    nav_frame, content_frame = resolve_ccs_frames(page)

    select_elements = content_frame.locator("select")
    select_count = await select_elements.count()

    if select_count == 0:
        raise RuntimeError("No <select> elements found on page")

    for i in range(select_count):
        select = select_elements.nth(i)

        try:
            option = select.locator("option", has_text=option_text)
            if await option.count() == 0:
                continue

            await select.wait_for(state="visible", timeout=20000)
            await select.select_option(label=option_text)

            logger.info(
                LogCategory.EXECUTION,
                f"[PHASE 3] SELECT successful: {option_text}"
            )
            return

        except Exception:
            continue

    raise RuntimeError(
        f"Option '{option_text}' not found in any <select> element"
    )






async def refresh_content_frame(page):
    for _ in range(10):
        for frame in page.frames:
            if "ccs.do" in frame.url:
                return frame
        await asyncio.sleep(0.5)
    raise RuntimeError("Unable to resolve CCS content frame after navigation")


elif action_type == "SELECT":
    content_frame = await refresh_content_frame(page)



await click_nav_link(nav_frame, target)

# â¬‡â¬‡â¬‡ REQUIRED
await page.wait_for_load_state("networkidle")
content_frame = await refresh_content_frame(page)




def resolve_ccs_frames(page):
    nav_frame = None
    content_frame = None

    for frame in page.frames:
        url = frame.url or ""

        # Navigation frame: contains top tabs (Customer, Claims, etc.)
        if "currentNavPosition" in url or "nav" in url:
            nav_frame = frame

        # Content frame: CCS business pages
        elif "ccs/" in url and not "currentNavPosition" in url:
            content_frame = frame

    if not content_frame:
        raise RuntimeError("CCS content frame not found")

    # nav_frame may temporarily disappear during transitions
    return nav_frame, content_frame


