elif action_type == "RADIO":
    step_lower = step_name.lower()

    # Extract answer index (answer = 1 / 2)
    match = re.search(r"answer\s*=\s*(\d+)", step_lower)
    if not match:
        raise RuntimeError("RADIO step must specify answer = <number>")

    answer_index = match.group(1)

    # Resolve frames
    nav_frame, content_frame = resolve_ccs_frames(page)

    # ============================================================
    # EXTENDED STABILIZATION
    # ============================================================
    logger.info(LogCategory.EXECUTION, "[DEBUG] Waiting for page to stabilize...")
    await page.wait_for_timeout(3000)
    
    try:
        await content_frame.wait_for_load_state("networkidle", timeout=15000)
    except Exception as e:
        logger.warning(LogCategory.EXECUTION, f"[DEBUG] Network didn't stabilize: {str(e)}")
    
    await page.wait_for_timeout(2000)

    # ============================================================
    # STRATEGY: Find ALL radio groups (WITH ERROR HANDLING)
    # ============================================================
    
    try:
        radio_groups = await content_frame.evaluate("""
            () => {
                const radios = Array.from(document.querySelectorAll('input[type="radio"]'));
                const groups = {};
                
                radios.forEach(radio => {
                    const name = radio.name;
                    if (!groups[name]) {
                        groups[name] = [];
                    }
                    
                    // Check if element is actually visible
                    const rect = radio.getBoundingClientRect();
                    const isVisible = (
                        radio.offsetParent !== null &&
                        rect.width > 0 && 
                        rect.height > 0 &&
                        window.getComputedStyle(radio).visibility !== 'hidden' &&
                        window.getComputedStyle(radio).display !== 'none'
                    );
                    
                    groups[name].push({
                        id: radio.id,
                        name: radio.name,
                        value: radio.value,
                        checked: radio.checked,
                        visible: isVisible,
                        top: rect.top,
                        left: rect.left
                    });
                });
                
                return groups;
            }
        """)
    except Exception as e:
        logger.error(LogCategory.EXECUTION, f"[DEBUG] Failed to evaluate radio groups: {str(e)}")
        raise RuntimeError(f"Failed to discover radio button groups: {str(e)}")

    logger.info(
        LogCategory.EXECUTION,
        f"[DEBUG] Found {len(radio_groups)} radio button groups: {list(radio_groups.keys())}"
    )

    # ============================================================
    # SMART SELECTION: Prioritize groups with valid IDs and values
    # ============================================================
    target_group_name = None
    target_group_radios = []

    # Priority 1: Groups with 'answer' in the name (ERBE scenario radios)
    for group_name, radios in radio_groups.items():
        if 'answer' in group_name.lower():
            visible_radios = [r for r in radios if r['visible'] and r['id']]
            if visible_radios and len(visible_radios) >= 2:
                target_group_name = group_name
                target_group_radios = visible_radios
                logger.info(
                    LogCategory.EXECUTION,
                    f"[DEBUG] Priority match: Found 'answer' group: {group_name}"
                )
                break

    # Priority 2: Groups with 'customerType' (Customer search radios)
    if not target_group_name:
        for group_name, radios in radio_groups.items():
            if 'customertype' in group_name.lower():
                visible_radios = [r for r in radios if r['visible'] and r['id']]
                if visible_radios:
                    target_group_name = group_name
                    target_group_radios = visible_radios
                    logger.info(
                        LogCategory.EXECUTION,
                        f"[DEBUG] Priority match: Found 'customerType' group: {group_name}"
                    )
                    break

    # Priority 3: Any group with visible radios (excluding filters)
    if not target_group_name:
        for group_name, radios in radio_groups.items():
            if 'filter' in group_name.lower():
                continue
                
            visible_radios = [r for r in radios if r['visible'] and r['id']]
            if visible_radios and len(visible_radios) >= 2:
                target_group_name = group_name
                target_group_radios = visible_radios
                logger.info(
                    LogCategory.EXECUTION,
                    f"[DEBUG] Fallback match: Found group: {group_name}"
                )
                break

    if not target_group_name:
        raise RuntimeError("No visible radio button groups found on page")

    logger.info(
        LogCategory.EXECUTION,
        f"[DEBUG] Selected radio group: {target_group_name} with {len(target_group_radios)} options"
    )

    # Log all radios in the selected group
    for i, radio in enumerate(target_group_radios):
        logger.info(
            LogCategory.EXECUTION,
            f"[DEBUG] Radio {i+1}: id={radio['id']}, value={radio['value']}, checked={radio['checked']}"
        )

    # ============================================================
    # Validate index
    # ============================================================
    idx = int(answer_index) - 1
    
    if idx < 0 or idx >= len(target_group_radios):
        raise RuntimeError(
            f"Radio button index {answer_index} out of range. "
            f"Group '{target_group_name}' has {len(target_group_radios)} options"
        )

    target_radio = target_group_radios[idx]
    radio_id = target_radio['id']

    if not radio_id:
        raise RuntimeError(f"Radio button at index {answer_index} has no ID")

    logger.info(
        LogCategory.EXECUTION,
        f"[DEBUG] Target radio: id={radio_id}, value={target_radio['value']}"
    )

    # ============================================================
    # CLICK using Playwright native methods (NO JAVASCRIPT)
    # ============================================================
    
    # Locate the radio button
    radio_locator = content_frame.locator(f"input[type='radio'][id='{radio_id}']")
    
    # Wait for it to be present
    try:
        await radio_locator.wait_for(state="attached", timeout=10000)
    except Exception as e:
        raise RuntimeError(f"Radio button with id '{radio_id}' not found: {str(e)}")
    
    # Scroll into view
    try:
        await radio_locator.scroll_into_view_if_needed(timeout=5000)
    except Exception as e:
        logger.warning(LogCategory.EXECUTION, f"[DEBUG] Scroll warning: {str(e)}")
    
    await page.wait_for_timeout(1000)
    
    # Wait for visibility
    try:
        await radio_locator.wait_for(state="visible", timeout=10000)
    except Exception as e:
        raise RuntimeError(f"Radio button id '{radio_id}' not visible: {str(e)}")
    
    # Click the radio button
    try:
        await radio_locator.click(force=True, timeout=10000)
    except Exception as e:
        raise RuntimeError(f"Failed to click radio button id '{radio_id}': {str(e)}")
    
    logger.info(
        LogCategory.EXECUTION,
        f"[DEBUG] Radio button clicked successfully"
    )
    
    # Wait for UI to update
    await page.wait_for_timeout(1000)

    # Verify selection (using Playwright method, not evaluate)
    try:
        is_checked = await radio_locator.is_checked()
    except Exception as e:
        logger.warning(LogCategory.EXECUTION, f"[DEBUG] Verification warning: {str(e)}")
        is_checked = False

    if not is_checked:
        # Retry once if not checked
        logger.warning(LogCategory.EXECUTION, "[DEBUG] Radio not checked, retrying...")
        try:
            await radio_locator.click(force=True, timeout=10000)
            await page.wait_for_timeout(1000)
            is_checked = await radio_locator.is_checked()
        except Exception as e:
            raise RuntimeError(f"Failed to verify radio selection: {str(e)}")

    if not is_checked:
        raise RuntimeError(
            f"Radio button id='{radio_id}' was clicked but is not checked"
        )

    logger.info(
        LogCategory.EXECUTION,
        f"[PHASE 3] RADIO selected successfully: answer={answer_index}, "
        f"group={target_group_name}, id={radio_id}, value={target_radio['value']}"
    )

    await page.wait_for_timeout(1500)
